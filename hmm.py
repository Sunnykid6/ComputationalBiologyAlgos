# -*- coding: utf-8 -*-
"""HMM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TgPTgfuN7K32k5OhE0tdu8GGWWMIT2tj
"""

import math

multPath = []
# Helper function to initialize a matrix 1 greater than the sequence lengths
# Initializes the spaces to 0
def createMatrix(xLen, yLen):
  return [[0] * (xLen + 2) for ys in range(yLen)]

# Helper function to print out the matrix nicely
def printPrettyMatrix(mtxXY):
  return print('\n'.join([''.join(['{:8}'.format(item) for item in row]) 
      for row in mtxXY]))

# just sets up the matrix to look good
def setMatrix(mtxXY, numSeq):
  mtxXY[0][0] = "-"
  mtxXY[0][1] = "       0"
  mtxXY[1][0] = "0" 
  mtxXY[2][0] = "H"
  mtxXY[3][0] = "L"
  # Sets s1 to Sn on the outside of the matrix
  for i in range(len(numSeq)):
    mtxXY[0][i + 2] = "       " + numSeq[i]
    mtxXY[1][i + 2] = "    -inf"
  mtxXY[2][1] = "    -inf"
  mtxXY[3][1] = "    -inf"
  return mtxXY

# Uses the forward algorithm to calculate the probability
# of producing x given the model
def calcProbability(mtx, numSeq, starts, trans, emits):
  high = starts["H"] * emits["H"][numSeq[0]] 
  low = starts["L"] * emits["L"][numSeq[0]]
  mtx[2][2] = high
  mtx[3][2] = low
  j = 3

  for i in range(1, len(numSeq)):
    tempHigh = emits["H"][numSeq[i]] * (trans["H"]["H"] * high + trans["L"]["H"] * low)
    tempLow = emits["L"][numSeq[i]] * (trans["L"]["L"] * low + trans["H"]["L"] * high)
    mtx[2][i + 2] = '{:0.2e}'.format(tempHigh)
    mtx[3][i + 2] = '{:0.2e}'.format(tempLow)
    if i == 3:
      total = tempHigh + tempLow
      posteriorProbH = tempHigh / total
      posteriorProbL = 1 - posteriorProbH
    high = tempHigh
    low = tempLow
  result = ('{:0.2e}'.format(float(high + low)), mtx, '{:0.2e}'.format(float(posteriorProbH)), '{:0.2e}'.format(float(posteriorProbL)))
  return result

# Calculates the Values for part b, c, d, and e
# Takes in the HMM and uses the log version of converting the values using log base 2
# We then use those values to calculate the viterbi table
# Then based on the values in the viterbi table, we take the max value and find the
# most probable path
def logViterbiTable(mtx, numSeq, starts, trans, emits):
  newStart = {"H": math.log2(starts["H"]), "L": math.log2(starts["L"])}
  newTrans = {
              "H": {"H": math.log2(trans["H"]["H"]), "L": math.log2(trans["H"]["L"])},
              "L": {"L": math.log2(trans["L"]["L"]), "H": math.log2(trans["L"]["H"])},
             }
  newEmits = {
              "H": {"A": math.log2(emits["H"]["A"]), "G": math.log2(emits["H"]["G"]), "C": math.log2(emits["H"]["C"]), "T": math.log2(emits["H"]["T"])},
              "L": {"A": math.log2(emits["L"]["A"]), "G": math.log2(emits["L"]["G"]), "C": math.log2(emits["L"]["C"]), "T": math.log2(emits["L"]["T"])},
             }
  high = newStart["H"] + newEmits["H"][numSeq[0]]
  low = newStart["L"] + newEmits["L"][numSeq[0]]
  mtx[2][2] = round(high, 3)
  mtx[3][2] = round(low, 3)

  # the viterbi table
  for i in range(1, len(numSeq)):
    tempHigh = newEmits["H"][numSeq[i]] + max(newTrans["H"]["H"] + high, newTrans["L"]["H"] + low)
    tempLow = newEmits["L"][numSeq[i]] + max(newTrans["L"]["L"] + low, newTrans["H"]["L"] + high)
    mtx[2][i + 2] = round(tempHigh, 3)
    mtx[3][i + 2] = round(tempLow, 3)
    high = tempHigh
    low = tempLow
  orderString = ""
  lastString = ""
  dupe = False
  # Finding the most probable path
  for j in range(len(numSeq), 0, -1):
    if mtx[2][j + 1] > mtx[3][j + 1]:
      if j == len(numSeq):
        orderString = "H" + orderString
        lastString = "H"
      else:
        orderString = "H" + orderString
        lastString = "H"
    else:
      if j == len(numSeq):
        orderString = "L" + orderString
        lastString = "L"
      elif mtx[2][j + 1] < mtx[3][j + 1]:
        orderString = "L" + orderString
        lastString = "L"
      else:
        dupe = True
        if lastString == "H":
          orderString = "H" + orderString
          lastString = "H"
        else:
          orderString = "L" + orderString
          lastString = "L"
  return(mtx, orderString, '{:0.2e}'.format(2**mtx[3][len(numSeq) + 1]), dupe)

# recursion help to find the proper amount of multiple paths
# go through the 2 base pairs and further ones added
#   then for each string path, switch the letters at the indexes found
# afterwards we add them to the list and create a set out of them
#   to remove dupes. We then store prev set and new set and compare the 
#   lengths. If the new set  is greater we  go back into rechelp to find
#   if there are anymore
# then iterate through the final set and add them to a global array for 
#   printing later
def recHelp(accSet, prevSet, results, index):
  for i in range(len(results)):
    for j in range(1, len(index)):
      temp = ""
      for k in range(len(results[i]), 0, -1):
        if k == index[j]:
          if results[i][k - 1] == "H":
            temp = "L" + temp
            temp = (results[i])[0:k-1] + temp
            results.append(temp)
          else:
            temp = "H" + temp
            temp = (results[i])[0:k-1] + temp
            results.append(temp)
        else:
          temp = results[i][k -1] + temp
  accSets = set(results)
  if len(accSets) > len(prevSet):
    recHelp(set(), accSets, results, index)
  else:
    for i in range(len(list(accSets))):
      multPath.append(list(accSets)[i])
    return

# The start of the multPath calc to find the first pair of indices
#   to change and then based on that send it to the recursion help
#   and find out all the paths
def returnMult(logmtx, numSeq, probSeq):
  index = []
  for i in range(len(numSeq), 0, -1):
    if logmtx[2][i + 1] == logmtx[3][i + 1]:
      index.append(i)
  results = []
  results.append(probSeq)
  temp = ""
  # get the base 2
  for j in range(len(probSeq), 0, -1):
    if j == index[0]:
      if probSeq[j - 1] == "H":
        temp = "L"+ temp
      else:
        temp = "H" + temp
    else:
      temp = probSeq[j - 1] + temp
  results.append(temp)
  #use base 2 to do something
  recHelp(set(), set(), results, index)
  return
    
def main():
  # Create the HMM
  obs = ("A", "G", "C", "T")
  states = ("H", "L")
  start_p = {"H": 0.5, "L": 0.5}
  trans_p = {"H": {"H": 0.6, "L": 0.4},
             "L": {"L": 0.5, "H": 0.5},
            }
  emit_p = {
            "H": {"A": 0.2, "G": 0.3, "C": 0.3, "T": 0.2},
            "L": {"A": 0.3, "G": 0.2, "C": 0.2, "T": 0.3},
            }       
  # Read the file
  file = open('4.in', 'r')
  s1 = (file.readline()).rstrip()
  # checks to see if in fasta format, checks theh first char in string to see if its >
  # if not we reject
  if s1[0] == ">":
    s2 = (file.readline()).rstrip()
    # checks to see if the sequence is less than 4 or greater than 100, if so don't run
    if len(s2) < 4 or len(s2) > 100:
      print("not enough or too many in sequence")
    else:
      # Create two matrices one to calculate the prob
      # the other for log base 2 viterbi table
      empTable = setMatrix(createMatrix(len(s2), 4), s2)
      empTable2 = setMatrix(createMatrix(len(s2), 4), s2)
      q1q6Ans = calcProbability(empTable, s2, start_p, trans_p, emit_p)
      q2q3q4q5Ans = logViterbiTable(empTable2, s2, start_p, trans_p, emit_p)
      print("output 1:\n")
      print(q1q6Ans[0])
      print("\noutput 2:\n")
      print("Viterbi Table in Log base 2")
      printPrettyMatrix(q2q3q4q5Ans[0])
      print("\noutput 3:\n")
      print(q2q3q4q5Ans[1])
      print("\noutput 4:\n")
      print(q2q3q4q5Ans[2])
      print("\noutput 5:\n")
      if q2q3q4q5Ans[3] == True:
        print("YES")
        # only if yes we find out all the paths
        returnMult(q2q3q4q5Ans[0], s2, q2q3q4q5Ans[1])
      else:
        print("NO")
      print("\noutput 6:\n")
      print(q1q6Ans[2])
      print(q1q6Ans[3])
      print("\noutput 7:")
      if q2q3q4q5Ans[3] == True:
        print(len(multPath))
        print("\n")
        for i in range(len(multPath)):
          print(multPath[i])
          print("\n")
      else:
        print("There were no extra paths")
  else:
    print("not in FASTA format")
  file.close()

main()

