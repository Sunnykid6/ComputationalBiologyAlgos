# -*- coding: utf-8 -*-
"""UPGMA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19tcJXp5p76WQ-Za0wlvevzzdc4qfWx0h
"""

# Helper function to initialize a matrix 1 greater than the sequence lengths
# to support the addition of adding each s1 to sn on the sides as markers
# Initializes the spaces to 0
# Returns a list of lists (matrix) full of 0s
tbtn = False
def createMatrix(xyLen):
  return [[0] * (xyLen + 1) for ys in range(xyLen+1)]

# Counts the differences bewteen two sequences
def difference(seq1, seq2):
    count = 0
    for i in range(len(seq1)):
        if seq1[i] != seq2[i]:
            count += 1
    return count

# I was trying to fix the rounding of numbers but that led to some numbers being too far
# from the given ones in the doc so I changed it back to how python rounds numbers.
# Python 3 rounds them to the closest even number so ie 1.5 rounds to 2 and 2.5 rounds to 2
# So 1.85 would round to 1.8 while 1.75 also rounds to 1.8 so that may be where the discrepencies lie
def normal_round(n, decimals=1):
    return round(n, decimals)

# Main function for creating the matrix and calling other functions to create the text based
# tree. This also outputs the answers to questions 1 to 3. I decided not to do the bonus question
def setMatrix(numSeq, actSeq, mtxXY, updated):
  mtxXY[0][0] = "-"
  # Sets s1 to Sn on the outside of the matrix
  for i in range(len(numSeq)):
    mtxXY[0][i + 1] = "    " + numSeq[i].strip(">")
    mtxXY[i + 1][0] = numSeq[i].strip(">")
  # Puts the calcuations from differences into the right spaces starting from
  # [1,1] because the outer ring is taken up by the labels
  for i in range(1, len(actSeq) + 1):
    for j in range(1, len(actSeq) + 1):
      mtxXY[i][j] = difference(actSeq[i - 1], actSeq[j - 1])
      updated[i - 1][j - 1] = difference(actSeq[i - 1], actSeq[j - 1])
  
  #updated[0][1] = 4
  temp = updated
  temp2 = numSeq
  multIndex = findMin(len(numSeq), updated)
  print("output 1: \n")
  printPrettyMatrix(mtxXY)
  # Tries to calculate the and update a copy of the distance matrix based on wikipedia
  # It looked like when it had a cluster of two the calculation changed
  # As well when it was 1 away from the end ie 2x2 matrix, the matrix was calculated
  # from the remaining cells so we chaanged the sequence up.
  numTimes = (len(numSeq)) - 1
  finalString = []
  # do the calculations based on how many min values found to find all trees
  for j in range(len(multIndex[2])):
    updated = temp
    numSeq = temp2
    strarr = []
    minarr = []
    ordarr = []
    #calculate one time to find the right tree to start if there are more
    distanceUpdate = startUpdateMatrix(numSeq, len(numSeq), updated, multIndex[2][j])
    numSeq = distanceUpdate[0]
    updated = distanceUpdate[2]
    strarr.append(distanceUpdate[3])    
    minarr.append(distanceUpdate[4]) 
    ordarr.insert(0, (distanceUpdate[5]))
    # subsequent update distance calculations
    for i in range(numTimes, 1, -1):
      # cluster of 2
      if i == numTimes:
        distanceUpdate = updateMatrix2(numSeq, len(numSeq), updated)
        numSeq = distanceUpdate[0]
        updated = distanceUpdate[2]
        strarr.append(distanceUpdate[3])    
        minarr.append(distanceUpdate[4]) 
        ordarr.insert(0, (distanceUpdate[5]))
      # 2x2 matrix
      elif i == 3:
        distanceUpdate = updateMatrix3(numSeq, len(numSeq), updated)
        numSeq = distanceUpdate[0]
        updated = distanceUpdate[2]
        strarr.append(distanceUpdate[3])    
        minarr.append(distanceUpdate[4]) 
        ordarr.insert(0, (distanceUpdate[5]))
      # else its a regular calc
      else:
        distanceUpdate = updateMatrix(numSeq, len(numSeq), updated)
        numSeq = distanceUpdate[0]
        updated = distanceUpdate[2]
        strarr.append(distanceUpdate[3])
        minarr.append(distanceUpdate[4])
        ordarr.insert(0, (distanceUpdate[5]))
    ordarr.append("S1")  
    finSeqOrd = ordarr + strarr
    disVal = calcValues(minarr)
    finalString.append(outputString(finSeqOrd, disVal, strarr))
  #print(testing)
  print("\noutput 2: \n")
  print(finalString[0])
  print("\noutput 3: \n")
  if len(multIndex[2]) > 1:
    print("YES\n")
    print("output 4:\n")
    for i in range(len(finalString)):
      print(finalString[i])
  else:
    print("NO\n")
    print("output 4:\n")
    print("only the one above")
  return mtxXY

# calculates the updated distances between updated distance matrixes
# returns one array with them all 
def calcValues(seqVal):
  singleSeqValues = []
  multiSeqValues = []
  singleSeqValues.append(seqVal[0] / 2)

  for i in range(len(seqVal)):
    singleSeqValues.append((seqVal[i] / 2))
  
  for i in range(len(seqVal) - 1):
    multiSeqValues.append((normal_round(singleSeqValues[i + 2] - singleSeqValues[i + 1])))

  finalarr = multiSeqValues[::-1] + singleSeqValues 
  finalarr = finalarr[::-1]
  for i in range(len(finalarr)):
    finalarr[i] = normal_round(finalarr[i], 1)
  return finalarr

# Outputs the tree in the right order
# Takes in calculated values and the sequences
# and outputs them all in the right order
def outputString(seqStr, disVal, strarr):
  result = ""
  count = 1
  for i in range(len(seqStr) - 1, -1, -1):
    #print(i)
    if i == len(seqStr) - 1:
      result = result + seqStr[i]
    else:
      if i > ((len(seqStr)) - (len(strarr)) - 1):
        result = result + "(" + seqStr[i] + ":" + str(disVal[i]) 
      else:
        result = result + "(" + seqStr[i] + ":" + str(disVal[i]) + ")"
        if count >= 2 and i > 0:
          result = result + ")"
        count = count + 1
  return result

# Finds the min in the top row of the matrix
# This is for the distance update and shrinking of matrix
def findMin(seqLen, toUpdate):
  min = float("inf")
  index = 0
  allMinIndex = []
  for i in range(seqLen):
    if toUpdate[0][i] < min and toUpdate[0][i] != 0:
      min = toUpdate[0][i]
      index = i
  for i in range(seqLen):
    if toUpdate[0][i] == min:
      allMinIndex.append(i)
  return (min, index, allMinIndex)

# Distance updating to shrink the matrix
# This is when there is a 3x3 matrix going into 2x2 matrix
# only a few things to check and a bit different from the rest
def updateMatrix3(numSeq, seqLen, toUpdate):
  minVal = findMin(seqLen, toUpdate)
  newNumSeq = []
  for i in range(seqLen):
    if i == 0:
      newNumSeq.append(numSeq[i].strip(">") + numSeq[minVal[1]].strip(">S"))
    elif i == minVal[1]:
      continue
    else:
      newNumSeq.append(numSeq[i].strip(">"))
  newMatrixtoUpdate = createMatrix(len(newNumSeq) - 1)

  a = 0
  b = minVal[1]
  for i in range(len(newNumSeq)):
    for j in range(len(newNumSeq)):
      if i == a:        
        if i == j:
          newMatrixtoUpdate[i][j] = 0
        else:
          if j == b:
            newMatrixtoUpdate[i][j] = ((toUpdate[i][j + 1] + toUpdate[i + 1][j + 1]) / 2)
          else:
            newMatrixtoUpdate[i][j] = ((toUpdate[i][j] + toUpdate[i + 1][j + 1]) / 2)
  return (newNumSeq, len(newNumSeq), newMatrixtoUpdate, newNumSeq[0], minVal[0], numSeq[minVal[1]].strip(">"))

# Distance updating to shrink the matrix
# This should only run the second time through when the matrix
# is a double cluster and needs uses proportional averaging
def updateMatrix2(numSeq, seqLen, toUpdate):
  minVal = findMin(seqLen, toUpdate)
  newNumSeq = []
  for i in range(seqLen):
    if i == 0:
      newNumSeq.append(numSeq[i].strip(">") + numSeq[minVal[1]].strip(">S"))
    elif i == minVal[1]:
      continue
    else:
      newNumSeq.append(numSeq[i].strip(">"))
  newMatrixtoUpdate = createMatrix(len(newNumSeq) - 1)

  a = 0
  b = minVal[1]
  for i in range(len(newNumSeq)):
    for j in range(len(newNumSeq)):
      if i == a:        
        if i == j:
          newMatrixtoUpdate[i][j] = 0
        else:
          if j >= b:
            newMatrixtoUpdate[i][j] = ((((toUpdate[i][j + 1]) * 2 + (toUpdate[j + 1][b])) / 3))
          else:
            newMatrixtoUpdate[i][j] = (((toUpdate[i][j]) * 2 + (toUpdate[j][b])) / 3)
      else:
        if newMatrixtoUpdate[i][j] == 0:
          if i == j:
            newMatrixtoUpdate[i][j] = 0
          else:
            if j >= b:
              newMatrixtoUpdate[i][j] = toUpdate[i][j + 1]
  return (newNumSeq, len(newNumSeq), newMatrixtoUpdate, newNumSeq[0], minVal[0], numSeq[minVal[1]].strip(">"))

# Distance updating to shrink the matrix
# For all other cases its just a regular calc
def updateMatrix(numSeq, seqLen, toUpdate):
  minVal = findMin(seqLen, toUpdate)
  newNumSeq = []
  for i in range(seqLen):
    if i == 0:
      newNumSeq.append(numSeq[i].strip(">") + numSeq[minVal[1]].strip(">S"))
    elif i == minVal[1]:
      continue
    else:
      newNumSeq.append(numSeq[i].strip(">"))
  newMatrixtoUpdate = createMatrix(len(newNumSeq) - 1)

  a = 0
  b = minVal[1]
  for i in range(len(newNumSeq)):
    for j in range(len(newNumSeq)):
      if i == a:        
        if i == j:
          newMatrixtoUpdate[i][j] = 0
        else:
          if j >= b:
            newMatrixtoUpdate[i][j] = ((toUpdate[j + 1][a] + toUpdate[j + 1][minVal[1]]) / 2)
            newMatrixtoUpdate[j][i] = newMatrixtoUpdate[i][j]
          else:
            newMatrixtoUpdate[i][j] = ((toUpdate[j][a] + toUpdate[j][minVal[1]]) / 2)
            newMatrixtoUpdate[j][i] = newMatrixtoUpdate[i][j]
      elif i >= b:
        if newMatrixtoUpdate[i][j] == 0:
          if i == j:
            newMatrixtoUpdate[i][j] = 0
          else:
            if j >= b:
              newMatrixtoUpdate[i][j] = toUpdate[i + 1][j + 1]
            else:
              newMatrixtoUpdate[i][j] = toUpdate[i + 1][j]
        else:
          continue
      else:
        if newMatrixtoUpdate[i][j] == 0:
          if i == j:
            newMatrixtoUpdate[i][j] = 0
          else:
            if j >= b:
              newMatrixtoUpdate[i][j] = toUpdate[i][j + 1]
        else:
          continue
  return (newNumSeq, len(newNumSeq), newMatrixtoUpdate, newNumSeq[0], minVal[0], numSeq[minVal[1]].strip(">"))

#only for the first run through of distance calculations as
#I need to pass in the minIndex for if there are multiple of
# the same  min values
def startUpdateMatrix(numSeq, seqLen, toUpdate, minIndex):
  #minVal = findMin(seqLen, toUpdate)
  newNumSeq = []
  for i in range(seqLen):
    if i == 0:
      newNumSeq.append(numSeq[i].strip(">") + numSeq[minIndex].strip(">S"))
    elif i == minIndex:
      continue
    else:
      newNumSeq.append(numSeq[i].strip(">"))
  newMatrixtoUpdate = createMatrix(len(newNumSeq) - 1)

  a = 0
  b = minIndex
  for i in range(len(newNumSeq)):
    for j in range(len(newNumSeq)):
      if i == a:        
        if i == j:
          newMatrixtoUpdate[i][j] = 0
        else:
          if j >= b:
            newMatrixtoUpdate[i][j] = ((toUpdate[j + 1][a] + toUpdate[j + 1][minIndex]) / 2)
            newMatrixtoUpdate[j][i] = newMatrixtoUpdate[i][j]
          else:
            newMatrixtoUpdate[i][j] = ((toUpdate[j][a] + toUpdate[j][minIndex]) / 2)
            newMatrixtoUpdate[j][i] = newMatrixtoUpdate[i][j]
      elif i >= b:
        if newMatrixtoUpdate[i][j] == 0:
          if i == j:
            newMatrixtoUpdate[i][j] = 0
          else:
            if j >= b:
              newMatrixtoUpdate[i][j] = toUpdate[i + 1][j + 1]
            else:
              newMatrixtoUpdate[i][j] = toUpdate[i + 1][j]
        else:
          continue
      else:
        if newMatrixtoUpdate[i][j] == 0:
          if i == j:
            newMatrixtoUpdate[i][j] = 0
          else:
            if j >= b:
              newMatrixtoUpdate[i][j] = toUpdate[i][j + 1]
        else:
          continue
  return (newNumSeq, len(newNumSeq), newMatrixtoUpdate, newNumSeq[0], toUpdate[0][minIndex], numSeq[minIndex].strip(">"))

def printPrettyMatrix(mtxXY):
  return print('\n'.join([''.join(['{:6}'.format(item) for item in row]) 
      for row in mtxXY]))

def main():
  # Change the input to whatever input file you need it to be. Jupyter deletes files after session
  # Ensure that the lines are seperated by S(n) and then sequence
  numSeq = []
  actSeq = []
  upMtx= []
  # runs the file and appends each ">S(N)" to an list and the others to another list
  # numSeq is the number of ">S(N" and actSeq is the actual sequence
  file = open('3.in', 'r')
  while file:
    for line in file:
      if line.startswith(">"):
        numSeq.append(line.rstrip())
      else:
        actSeq.append(line.rstrip())
    break
  file.close()
  #Checks to see that the number of sequences is between 3 and 10 and checks that the actual sequence is greater than 200
  if len(numSeq) < 3 or len(numSeq) > 10 or len(actSeq[0]) > 200:
    print("too little or too many sequences in the list")
  else:
    upMtx = createMatrix(len(numSeq) - 1)
    setMatrix(numSeq, actSeq, createMatrix(len(numSeq)), upMtx)
main()